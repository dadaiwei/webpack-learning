"use strict";

exports.__esModule = true;
exports.default = buildConfigChain;

var _environment = require("./helpers/environment");

var _path = _interopRequireDefault(require("path"));

var _micromatch = _interopRequireDefault(require("micromatch"));

var _debug = _interopRequireDefault(require("debug"));

var _files = require("./loading/files");

var _caching = require("./caching");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var debug = (0, _debug.default)("babel:config:config-chain");

function buildConfigChain(opts) {
  if (typeof opts.filename !== "string" && opts.filename != null) {
    throw new Error(".filename must be a string, null, or undefined");
  }

  var filename = opts.filename ? _path.default.resolve(opts.filename) : null;
  var builder = new ConfigChainBuilder(filename ? new LoadedFile(filename) : null);
  var envKey = (0, _environment.getEnv)();

  try {
    builder.mergeConfigArguments(opts, process.cwd(), envKey);

    if (opts.babelrc !== false && filename) {
      (0, _files.findConfigs)(_path.default.dirname(filename)).forEach(function (configFile) {
        return builder.mergeConfigFile(configFile, envKey);
      });
    }
  } catch (e) {
    if (e.code !== "BABEL_IGNORED_FILE") throw e;
    return null;
  }

  return builder.configs.reverse();
}

var ConfigChainBuilder = function () {
  function ConfigChainBuilder(file) {
    Object.defineProperty(this, "configs", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: []
    });
    this.file = file;
  }

  var _proto = ConfigChainBuilder.prototype;

  _proto.mergeConfigArguments = function mergeConfigArguments(opts, dirname, envKey) {
    var _this = this;

    flattenArgumentsOptionsParts(opts, dirname, envKey).forEach(function (part) {
      return _this._processConfigPart(part, envKey);
    });
  };

  _proto.mergeConfigFile = function mergeConfigFile(file, envKey) {
    var _this2 = this;

    flattenFileOptionsParts(file)(envKey).forEach(function (part) {
      return _this2._processConfigPart(part, envKey);
    });
  };

  _proto._processConfigPart = function _processConfigPart(part, envKey) {
    if (part.part === "config") {
      var _ignore = part.ignore,
          _only = part.only;

      if (this.file && this.file.shouldIgnore(_ignore, _only, part.config.dirname)) {
        throw Object.assign(new Error("This file has been ignored."), {
          code: "BABEL_IGNORED_FILE"
        });
      }

      this.configs.push(part.config);
    } else {
      var extendsConfig = (0, _files.loadConfig)(part.path, part.dirname);
      var existingConfig = this.configs.some(function (config) {
        return config.alias === extendsConfig.filepath;
      });

      if (!existingConfig) {
        this.mergeConfigFile(extendsConfig, envKey);
      }
    }
  };

  return ConfigChainBuilder;
}();

function flattenArgumentsOptionsParts(opts, dirname, envKey) {
  var raw = [];
  var env = _typeof(opts.env) === "object" ? opts.env : null;
  var plugins = Array.isArray(opts.plugins) ? opts.plugins : null;
  var presets = Array.isArray(opts.presets) ? opts.presets : null;
  var passPerPreset = typeof opts.passPerPreset === "boolean" ? opts.passPerPreset : false;

  if (env) {
    raw.push.apply(raw, flattenArgumentsEnvOptionsParts(env)(dirname)(envKey));
  }

  var innerOpts = Object.assign({}, opts);
  if (env) delete innerOpts.env;
  if (plugins) delete innerOpts.plugins;

  if (presets) {
    delete innerOpts.presets;
    delete innerOpts.passPerPreset;
  }

  delete innerOpts.extends;

  if (Object.keys(innerOpts).length > 0) {
    raw.push.apply(raw, flattenOptionsParts({
      type: "arguments",
      options: innerOpts,
      alias: "base",
      dirname: dirname
    }));
  }

  if (plugins) {
    raw.push.apply(raw, flattenArgumentsPluginsOptionsParts(plugins)(dirname));
  }

  if (presets) {
    raw.push.apply(raw, flattenArgumentsPresetsOptionsParts(presets)(passPerPreset)(dirname));
  }

  if (opts.extends != null) {
    raw.push.apply(raw, flattenOptionsParts(buildArgumentsRawConfig({
      extends: opts.extends
    }, dirname)));
  }

  return raw;
}

var flattenArgumentsEnvOptionsParts = (0, _caching.makeWeakCache)(function (env) {
  var options = {
    env: env
  };
  return (0, _caching.makeStrongCache)(function (dirname) {
    return flattenOptionsPartsLookup(buildArgumentsRawConfig(options, dirname));
  });
});
var flattenArgumentsPluginsOptionsParts = (0, _caching.makeWeakCache)(function (plugins) {
  var options = {
    plugins: plugins
  };
  return (0, _caching.makeStrongCache)(function (dirname) {
    return flattenOptionsParts(buildArgumentsRawConfig(options, dirname));
  });
});
var flattenArgumentsPresetsOptionsParts = (0, _caching.makeWeakCache)(function (presets) {
  return (0, _caching.makeStrongCache)(function (passPerPreset) {
    var options = {
      presets: presets,
      passPerPreset: passPerPreset
    };
    return (0, _caching.makeStrongCache)(function (dirname) {
      return flattenOptionsParts(buildArgumentsRawConfig(options, dirname));
    });
  });
});

function buildArgumentsRawConfig(options, dirname) {
  return {
    type: "arguments",
    options: options,
    alias: "base",
    dirname: dirname
  };
}

var flattenFileOptionsParts = (0, _caching.makeWeakCache)(function (file) {
  return flattenOptionsPartsLookup({
    type: "options",
    options: file.options,
    alias: file.filepath,
    dirname: file.dirname
  });
});

function flattenOptionsPartsLookup(config) {
  var parts = flattenOptionsParts(config);
  var def = parts.filter(function (part) {
    return part.activeEnv === null;
  });
  var lookup = new Map();
  parts.forEach(function (part) {
    if (part.activeEnv !== null) lookup.set(part.activeEnv, []);
  });

  var _loop = function _loop(values, _activeEnv) {
    parts.forEach(function (part) {
      if (part.activeEnv === null || part.activeEnv === _activeEnv) {
        values.push(part);
      }
    });
  };

  for (var _iterator = lookup, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref2;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref2 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref2 = _i.value;
    }

    var _ref3 = _ref2;
    var _activeEnv = _ref3[0];
    var values = _ref3[1];

    _loop(values, _activeEnv);
  }

  return function (envKey) {
    return lookup.get(envKey) || def;
  };
}

function flattenOptionsParts(rawConfig, activeEnv) {
  if (activeEnv === void 0) {
    activeEnv = null;
  }

  var type = rawConfig.type,
      rawOpts = rawConfig.options,
      alias = rawConfig.alias,
      dirname = rawConfig.dirname;

  if (rawOpts.ignore != null && !Array.isArray(rawOpts.ignore)) {
    throw new Error(".ignore should be an array, " + JSON.stringify(rawOpts.ignore) + " given");
  }

  if (rawOpts.only != null && !Array.isArray(rawOpts.only)) {
    throw new Error(".only should be an array, " + JSON.stringify(rawOpts.only) + " given");
  }

  var ignore = rawOpts.ignore || null;
  var only = rawOpts.only || null;
  var parts = [];

  if (rawOpts.env != null && (_typeof(rawOpts.env) !== "object" || Array.isArray(rawOpts.env))) {
    throw new Error(".env block must be an object, null, or undefined");
  }

  var rawEnv = rawOpts.env || {};
  Object.keys(rawEnv).forEach(function (envKey) {
    var envOpts = rawEnv[envKey];

    if (envOpts !== undefined && activeEnv !== null && activeEnv !== envKey) {
      throw new Error("Unreachable .env[" + envKey + "] block detected");
    }

    if (envOpts != null && (_typeof(envOpts) !== "object" || Array.isArray(envOpts))) {
      throw new Error(".env[...] block must be an object, null, or undefined");
    }

    if (envOpts) {
      parts.push.apply(parts, flattenOptionsParts({
        type: type,
        options: envOpts,
        alias: alias + (".env." + envKey),
        dirname: dirname
      }, envKey));
    }
  });
  var options = Object.assign({}, rawOpts);
  delete options.env;
  delete options.extends;
  parts.push({
    part: "config",
    config: {
      type: type,
      options: options,
      alias: alias,
      loc: alias,
      dirname: dirname
    },
    ignore: ignore,
    only: only,
    activeEnv: activeEnv
  });

  if (rawOpts.extends != null) {
    if (typeof rawOpts.extends !== "string") {
      throw new Error(".extends must be a string");
    }

    parts.push({
      part: "extends",
      path: rawOpts.extends,
      dirname: dirname,
      activeEnv: activeEnv
    });
  }

  return parts;
}

var LoadedFile = function () {
  function LoadedFile(filename) {
    Object.defineProperty(this, "possibleDirs", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    this.filename = filename;
  }

  var _proto2 = LoadedFile.prototype;

  _proto2.shouldIgnore = function shouldIgnore(ignore, only, dirname) {
    if (ignore) {
      if (this._matchesPatterns(ignore, dirname)) {
        debug("Ignored %o because it matched one of %O from %o", this.filename, ignore, dirname);
        return true;
      }
    }

    if (only) {
      if (!this._matchesPatterns(only, dirname)) {
        debug("Ignored %o because it failed to match one of %O from %o", this.filename, only, dirname);
        return true;
      }
    }

    return false;
  };

  _proto2._matchesPatterns = function _matchesPatterns(patterns, dirname) {
    var res = [];
    var strings = [];
    var fns = [];
    patterns.forEach(function (pattern) {
      if (typeof pattern === "string") strings.push(pattern);else if (typeof pattern === "function") fns.push(pattern);else if (pattern instanceof RegExp) res.push(pattern);else {
        throw new Error("Patterns must be a string, function, or regular expression");
      }
    });
    var filename = this.filename;
    if (res.some(function (re) {
      return re.test(filename);
    })) return true;
    if (fns.some(function (fn) {
      return fn(filename);
    })) return true;

    if (strings.length > 0) {
      var possibleDirs = this.possibleDirs;

      if (!possibleDirs) {
        possibleDirs = this.possibleDirs = [];
        possibleDirs.push(filename);
        var current = filename;

        while (true) {
          var previous = current;
          current = _path.default.dirname(current);
          if (previous === current) break;
          possibleDirs.push(current);
        }
      }

      var absolutePatterns = strings.map(function (pattern) {
        var negate = pattern[0] === "!";
        if (negate) pattern = pattern.slice(1);
        return (negate ? "!" : "") + _path.default.resolve(dirname, pattern);
      });

      if ((0, _micromatch.default)(possibleDirs, absolutePatterns, {
        nocase: true
      }).length > 0) {
        return true;
      }
    }

    return false;
  };

  return LoadedFile;
}();