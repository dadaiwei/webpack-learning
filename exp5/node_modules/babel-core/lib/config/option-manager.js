"use strict";

exports.__esModule = true;
exports.default = manageOptions;

var context = _interopRequireWildcard(require("../index"));

var _plugin = _interopRequireDefault(require("./plugin"));

var _defaults = _interopRequireDefault(require("lodash/defaults"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _removed = _interopRequireDefault(require("./removed"));

var _buildConfigChain = _interopRequireDefault(require("./build-config-chain"));

var _path = _interopRequireDefault(require("path"));

var _babelTraverse = _interopRequireDefault(require("babel-traverse"));

var _clone = _interopRequireDefault(require("lodash/clone"));

var _caching = require("./caching");

var _environment = require("./helpers/environment");

var _files = require("./loading/files");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var optionNames = new Set(["relative", "filename", "filenameRelative", "inputSourceMap", "env", "mode", "retainLines", "highlightCode", "suppressDeprecationMessages", "presets", "plugins", "ignore", "only", "code", "ast", "extends", "comments", "shouldPrintComment", "wrapPluginVisitorMethod", "compact", "minified", "sourceMaps", "sourceMapTarget", "sourceFileName", "sourceRoot", "babelrc", "sourceType", "auxiliaryCommentBefore", "auxiliaryCommentAfter", "getModuleId", "moduleRoot", "moduleIds", "moduleId", "passPerPreset", "parserOpts", "generatorOpts"]);
var ALLOWED_PLUGIN_KEYS = new Set(["name", "manipulateOptions", "pre", "post", "visitor", "inherits"]);

function manageOptions(opts) {
  return new OptionManager().init(opts);
}

var OptionManager = function () {
  function OptionManager() {
    this.options = createInitialOptions();
    this.passes = [[]];
  }

  var _proto = OptionManager.prototype;

  _proto.mergeOptions = function mergeOptions(config, pass) {
    var _this = this;

    var result = loadConfig(config);
    var plugins = result.plugins.map(function (descriptor) {
      return loadPluginDescriptor(descriptor);
    });
    var presets = result.presets.map(function (descriptor) {
      return loadPresetDescriptor(descriptor);
    });

    if (config.options.passPerPreset != null && typeof config.options.passPerPreset !== "boolean") {
      throw new Error(".passPerPreset must be a boolean or undefined");
    }

    var passPerPreset = config.options.passPerPreset;
    pass = pass || this.passes[0];

    if (presets.length > 0) {
      var presetPasses = null;

      if (passPerPreset) {
        var _passes;

        presetPasses = presets.map(function () {
          return [];
        });

        (_passes = this.passes).splice.apply(_passes, [1, 0].concat(presetPasses));
      }

      presets.forEach(function (presetConfig, i) {
        _this.mergeOptions(presetConfig, presetPasses ? presetPasses[i] : pass);
      });
    }

    if (plugins.length > 0) {
      var _pass;

      (_pass = pass).unshift.apply(_pass, plugins);
    }

    (0, _merge.default)(this.options, result.options);
  };

  _proto.init = function init(opts) {
    var configChain = (0, _buildConfigChain.default)(opts);
    if (!configChain) return null;

    try {
      for (var _iterator = configChain, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _config = _ref;
        this.mergeOptions(_config);
      }
    } catch (e) {
      if (!/^\[BABEL\]/.test(e.message)) {
        var filename = typeof opts.filename === "string" ? opts.filename : null;
        e.message = "[BABEL] " + (filename || "unknown") + ": " + e.message;
      }

      throw e;
    }

    opts = this.options;
    opts.plugins = this.passes[0];
    opts.presets = this.passes.slice(1).filter(function (plugins) {
      return plugins.length > 0;
    }).map(function (plugins) {
      return {
        plugins: plugins
      };
    });

    if (opts.inputSourceMap) {
      opts.sourceMaps = true;
    }

    if (opts.moduleId) {
      opts.moduleIds = true;
    }

    (0, _defaults.default)(opts, {
      moduleRoot: opts.sourceRoot
    });
    (0, _defaults.default)(opts, {
      sourceRoot: opts.moduleRoot
    });
    (0, _defaults.default)(opts, {
      filenameRelative: opts.filename
    });

    var basenameRelative = _path.default.basename(opts.filenameRelative);

    if (_path.default.extname(opts.filenameRelative) === ".mjs") {
      opts.sourceType = "module";
    }

    (0, _defaults.default)(opts, {
      sourceFileName: basenameRelative,
      sourceMapTarget: basenameRelative
    });
    return {
      options: opts,
      passes: this.passes
    };
  };

  return OptionManager;
}();

var loadConfig = (0, _caching.makeWeakCache)(function (config) {
  var options = normalizeOptions(config);

  if (config.options.plugins != null && !Array.isArray(config.options.plugins)) {
    throw new Error(".plugins should be an array, null, or undefined");
  }

  var plugins = (config.options.plugins || []).map(function (plugin, index) {
    var _normalizePair = normalizePair(plugin, _files.loadPlugin, config.dirname),
        filepath = _normalizePair.filepath,
        value = _normalizePair.value,
        options = _normalizePair.options;

    return {
      alias: filepath || config.loc + "$" + index,
      loc: filepath || config.loc,
      value: value,
      options: options,
      dirname: config.dirname
    };
  });

  if (config.options.presets != null && !Array.isArray(config.options.presets)) {
    throw new Error(".presets should be an array, null, or undefined");
  }

  var presets = (config.options.presets || []).map(function (preset, index) {
    var _normalizePair2 = normalizePair(preset, _files.loadPreset, config.dirname),
        filepath = _normalizePair2.filepath,
        value = _normalizePair2.value,
        options = _normalizePair2.options;

    return {
      alias: filepath || config.loc + "$" + index,
      loc: filepath || config.loc,
      value: value,
      options: options,
      dirname: config.dirname
    };
  });
  return {
    options: options,
    plugins: plugins,
    presets: presets
  };
});
var loadDescriptor = (0, _caching.makeWeakCache)(function (_ref2, cache) {
  var value = _ref2.value,
      _ref2$options = _ref2.options,
      options = _ref2$options === void 0 ? {} : _ref2$options,
      dirname = _ref2.dirname,
      alias = _ref2.alias,
      loc = _ref2.loc;
  var item = value;

  if (typeof value === "function") {
    var api = Object.assign(Object.create(context), {
      cache: cache,
      env: function env() {
        return cache.using(function () {
          return (0, _environment.getEnv)();
        });
      }
    });

    try {
      item = value(api, options, {
        dirname: dirname
      });
    } catch (e) {
      if (alias) {
        e.message += " (While processing: " + JSON.stringify(alias) + ")";
      }

      throw e;
    }
  }

  if (!item || _typeof(item) !== "object") {
    throw new Error("Plugin/Preset did not return an object.");
  }

  return {
    value: item,
    options: options,
    dirname: dirname,
    alias: alias,
    loc: loc
  };
});

function loadPluginDescriptor(descriptor) {
  if (descriptor.value instanceof _plugin.default) {
    if (descriptor.options) {
      throw new Error("Passed options to an existing Plugin instance will not work.");
    }

    return descriptor.value;
  }

  return instantiatePlugin(loadDescriptor(descriptor));
}

var instantiatePlugin = (0, _caching.makeWeakCache)(function (_ref3, cache) {
  var pluginObj = _ref3.value,
      options = _ref3.options,
      dirname = _ref3.dirname,
      alias = _ref3.alias,
      loc = _ref3.loc;
  Object.keys(pluginObj).forEach(function (key) {
    if (!ALLOWED_PLUGIN_KEYS.has(key)) {
      throw new Error("Plugin " + alias + " provided an invalid property of " + key);
    }
  });

  if (pluginObj.visitor && (pluginObj.visitor.enter || pluginObj.visitor.exit)) {
    throw new Error("Plugins aren't allowed to specify catch-all enter/exit handlers. " + "Please target individual nodes.");
  }

  var plugin = Object.assign({}, pluginObj, {
    visitor: (0, _clone.default)(pluginObj.visitor || {})
  });

  _babelTraverse.default.explode(plugin.visitor);

  var inheritsDescriptor;
  var inherits;

  if (plugin.inherits) {
    inheritsDescriptor = {
      alias: loc + "$inherits",
      loc: loc,
      value: plugin.inherits,
      options: options,
      dirname: dirname
    };
    inherits = cache.invalidate(function () {
      return loadPluginDescriptor(inheritsDescriptor);
    });
    plugin.pre = chain(inherits.pre, plugin.pre);
    plugin.post = chain(inherits.post, plugin.post);
    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
    plugin.visitor = _babelTraverse.default.visitors.merge([inherits.visitor, plugin.visitor]);
  }

  return new _plugin.default(plugin, options, alias);
});

var loadPresetDescriptor = function loadPresetDescriptor(descriptor) {
  return instantiatePreset(loadDescriptor(descriptor));
};

var instantiatePreset = (0, _caching.makeWeakCache)(function (_ref4) {
  var value = _ref4.value,
      dirname = _ref4.dirname,
      alias = _ref4.alias,
      loc = _ref4.loc;
  return {
    type: "preset",
    options: value,
    alias: alias,
    loc: loc,
    dirname: dirname
  };
});

function normalizeOptions(config) {
  var alias = config.alias || "foreign";
  var type = config.type;

  if (_typeof(config.options) !== "object" || Array.isArray(config.options)) {
    throw new TypeError("Invalid options type for " + alias);
  }

  var options = Object.assign({}, config.options);

  if (type !== "arguments") {
    if (options.filename !== undefined) {
      throw new Error(alias + ".filename is only allowed as a root argument");
    }

    if (options.babelrc !== undefined) {
      throw new Error(alias + ".babelrc is only allowed as a root argument");
    }
  }

  if (type === "preset") {
    if (options.only !== undefined) {
      throw new Error(alias + ".only is not supported in a preset");
    }

    if (options.ignore !== undefined) {
      throw new Error(alias + ".ignore is not supported in a preset");
    }

    if (options.extends !== undefined) {
      throw new Error(alias + ".extends is not supported in a preset");
    }

    if (options.env !== undefined) {
      throw new Error(alias + ".env is not supported in a preset");
    }
  }

  if (options.sourceMap !== undefined) {
    if (options.sourceMaps !== undefined) {
      throw new Error("Both " + alias + ".sourceMap and .sourceMaps have been set");
    }

    options.sourceMaps = options.sourceMap;
    delete options.sourceMap;
  }

  for (var key in options) {
    if (!optionNames.has(key)) {
      if (_removed.default[key]) {
        var _removed$key = _removed.default[key],
            message = _removed$key.message,
            _removed$key$version = _removed$key.version,
            version = _removed$key$version === void 0 ? 5 : _removed$key$version;
        throw new ReferenceError("Using removed Babel " + version + " option: " + alias + "." + key + " - " + message);
      } else {
        var unknownOptErr = "Unknown option: " + alias + "." + key + ". Check out http://babeljs.io/docs/usage/options/ for more information about options.";
        throw new ReferenceError(unknownOptErr);
      }
    }
  }

  if (options.parserOpts && typeof options.parserOpts.parser === "string") {
    options.parserOpts = Object.assign({}, options.parserOpts);
    options.parserOpts.parser = (0, _files.loadParser)(options.parserOpts.parser, config.dirname).value;
  }

  if (options.generatorOpts && typeof options.generatorOpts.generator === "string") {
    options.generatorOpts = Object.assign({}, options.generatorOpts);
    options.generatorOpts.generator = (0, _files.loadGenerator)(options.generatorOpts.generator, config.dirname).value;
  }

  delete options.passPerPreset;
  delete options.plugins;
  delete options.presets;
  return options;
}

function normalizePair(pair, resolver, dirname) {
  var options;
  var value = pair;

  if (Array.isArray(pair)) {
    if (pair.length > 2) {
      throw new Error("Unexpected extra options " + JSON.stringify(pair.slice(2)) + ".");
    }

    value = pair[0];
    options = pair[1];
  }

  var filepath = null;

  if (typeof value === "string") {
    var _resolver = resolver(value, dirname);

    filepath = _resolver.filepath;
    value = _resolver.value;
  }

  if (!value) {
    throw new Error("Unexpected falsy value: " + String(value));
  }

  if (_typeof(value) === "object" && value.__esModule) {
    if (value.default) {
      value = value.default;
    } else {
      throw new Error("Must export a default export when using ES6 modules.");
    }
  }

  if (_typeof(value) !== "object" && typeof value !== "function") {
    throw new Error("Unsupported format: " + _typeof(value) + ". Expected an object or a function.");
  }

  if (options != null && _typeof(options) !== "object") {
    throw new Error("Plugin/Preset options must be an object, null, or undefined");
  }

  options = options || undefined;
  return {
    filepath: filepath,
    value: value,
    options: options
  };
}

function chain(a, b) {
  var fns = [a, b].filter(Boolean);
  if (fns.length <= 1) return fns[0];
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    for (var _iterator2 = fns, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref5 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref5 = _i2.value;
      }

      var _fn = _ref5;

      _fn.apply(this, args);
    }
  };
}

function createInitialOptions() {
  return {
    sourceType: "module",
    babelrc: true,
    filename: "unknown",
    code: true,
    ast: true,
    comments: true,
    compact: "auto",
    highlightCode: true
  };
}