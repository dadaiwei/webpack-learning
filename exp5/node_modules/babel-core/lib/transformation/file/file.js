"use strict";

exports.__esModule = true;
exports.default = void 0;

var _babelHelpers = _interopRequireDefault(require("babel-helpers"));

var _babelTraverse = _interopRequireWildcard(require("babel-traverse"));

var _babelCodeFrame = require("babel-code-frame");

var t = _interopRequireWildcard(require("babel-types"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var errorVisitor = {
  enter: function enter(path, state) {
    var loc = path.node.loc;

    if (loc) {
      state.loc = loc;
      path.stop();
    }
  }
};

var File = function () {
  function File(options, _ref) {
    var code = _ref.code,
        ast = _ref.ast,
        shebang = _ref.shebang,
        inputMap = _ref.inputMap;
    Object.defineProperty(this, "_map", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: new Map()
    });
    Object.defineProperty(this, "declarations", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "path", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "ast", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "metadata", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "hub", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: new _babelTraverse.Hub(this)
    });
    Object.defineProperty(this, "code", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "shebang", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "inputMap", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: null
    });
    this.opts = options;
    this.code = code;
    this.ast = ast;
    this.shebang = shebang;
    this.inputMap = inputMap;
    this.path = _babelTraverse.NodePath.get({
      hub: this.hub,
      parentPath: null,
      parent: this.ast,
      container: this.ast,
      key: "program"
    }).setContext();
    this.scope = this.path.scope;
  }

  var _proto = File.prototype;

  _proto.set = function set(key, val) {
    this._map.set(key, val);
  };

  _proto.get = function get(key) {
    return this._map.get(key);
  };

  _proto.getModuleName = function getModuleName() {
    var opts = this.opts;

    if (!opts.moduleIds) {
      return null;
    }

    if (opts.moduleId != null && !opts.getModuleId) {
      return opts.moduleId;
    }

    var filenameRelative = opts.filenameRelative;
    var moduleName = "";

    if (opts.moduleRoot != null) {
      moduleName = opts.moduleRoot + "/";
    }

    if (!opts.filenameRelative) {
      return moduleName + opts.filename.replace(/^\//, "");
    }

    if (opts.sourceRoot != null) {
      var sourceRootRegEx = new RegExp("^" + opts.sourceRoot + "/?");
      filenameRelative = filenameRelative.replace(sourceRootRegEx, "");
    }

    filenameRelative = filenameRelative.replace(/\.(\w*?)$/, "");
    moduleName += filenameRelative;
    moduleName = moduleName.replace(/\\/g, "/");

    if (opts.getModuleId) {
      return opts.getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  };

  _proto.resolveModuleSource = function resolveModuleSource(source) {
    return source;
  };

  _proto.addImport = function addImport() {
    throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'babel-helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
  };

  _proto.addHelper = function addHelper(name) {
    var _this = this;

    var declar = this.declarations[name];
    if (declar) return declar;
    var generator = this.get("helperGenerator");
    var runtime = this.get("helpersNamespace");

    if (generator) {
      var res = generator(name);
      if (res) return res;
    } else if (runtime) {
      return t.memberExpression(runtime, t.identifier(name));
    }

    var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);

    var _getHelper = (0, _babelHelpers.default)(name, function (name) {
      return _this.addHelper(name);
    }, uid, function () {
      return Object.keys(_this.scope.getAllBindings());
    }),
        nodes = _getHelper.nodes,
        globals = _getHelper.globals;

    globals.forEach(function (name) {
      if (_this.path.scope.hasBinding(name, true)) {
        _this.path.scope.rename(name);
      }
    });
    nodes.forEach(function (node) {
      node._compact = true;
    });
    this.path.unshiftContainer("body", nodes);
    this.path.get("body").forEach(function (path) {
      if (nodes.indexOf(path.node) === -1) return;
      if (path.isVariableDeclaration()) _this.scope.registerDeclaration(path);
    });
    return uid;
  };

  _proto.addTemplateObject = function addTemplateObject() {
    throw new Error("This function has been moved into the template literal transform itself.");
  };

  _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, Error) {
    if (Error === void 0) {
      Error = SyntaxError;
    }

    var loc = node && (node.loc || node._loc);
    msg = this.opts.filename + ": " + msg;

    if (!loc && node) {
      var state = {
        loc: null
      };
      (0, _babelTraverse.default)(node, errorVisitor, this.scope, state);
      loc = state.loc;
      var txt = "This is an error on an internal node. Probably an internal error.";
      if (loc) txt += " Location has been estimated.";
      msg += " (" + txt + ")";
    }

    if (loc) {
      msg += "\n" + (0, _babelCodeFrame.codeFrameColumns)(this.code, {
        start: {
          line: loc.line,
          column: loc.column + 1
        }
      }, this.opts);
    }

    return new Error(msg);
  };

  return File;
}();

exports.default = File;